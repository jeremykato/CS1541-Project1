------FIVE STAGE COUNTS: TEAM zacalbertjeremy -----
--------------SAMPLE TRACE-------------------

 ** opening file /afs/cs.pitt.edu/courses/1541/short_traces/sample.tr
+ Simulation terminates at cycle : 1156

 ** opening file /afs/cs.pitt.edu/courses/1541/short_traces/sample.tr
+ Simulation terminates at cycle : 1150
--------------LONG TRACES-------------------

 ** opening file /afs/cs.pitt.edu/courses/1541/long_traces/sample_large1.tr
+ Simulation terminates at cycle : 112886972

 ** opening file /afs/cs.pitt.edu/courses/1541/long_traces/sample_large1.tr
+ Simulation terminates at cycle : 104751986

 ** opening file /afs/cs.pitt.edu/courses/1541/long_traces/sample_large2.tr
+ Simulation terminates at cycle : 125422888

 ** opening file /afs/cs.pitt.edu/courses/1541/long_traces/sample_large2.tr
+ Simulation terminates at cycle : 117509911
--------------SHORT TRACES-------------------

 ** opening file /afs/cs.pitt.edu/courses/1541/short_traces/sample1.tr
+ Simulation terminates at cycle : 1267766

 ** opening file /afs/cs.pitt.edu/courses/1541/short_traces/sample1.tr
+ Simulation terminates at cycle : 1129674

 ** opening file /afs/cs.pitt.edu/courses/1541/short_traces/sample2.tr
+ Simulation terminates at cycle : 1215048

 ** opening file /afs/cs.pitt.edu/courses/1541/short_traces/sample2.tr
+ Simulation terminates at cycle : 1224391

 ** opening file /afs/cs.pitt.edu/courses/1541/short_traces/sample3.tr
+ Simulation terminates at cycle : 1351474

 ** opening file /afs/cs.pitt.edu/courses/1541/short_traces/sample3.tr
+ Simulation terminates at cycle : 1293841

 ** opening file /afs/cs.pitt.edu/courses/1541/short_traces/sample4.tr
+ Simulation terminates at cycle : 3834281

 ** opening file /afs/cs.pitt.edu/courses/1541/short_traces/sample4.tr
+ Simulation terminates at cycle : 3647921


------SUPERSCALAR COUNTS: TEAM zacalbertjeremy -----
--------------SAMPLE TRACE-------------------

 ** opening file /afs/cs.pitt.edu/courses/1541/short_traces/sample.tr
+ Simulation terminates at cycle : 1042
--------------LONG TRACES-------------------

 ** opening file /afs/cs.pitt.edu/courses/1541/long_traces/sample_large1.tr
+ Simulation terminates at cycle : 98969051

 ** opening file /afs/cs.pitt.edu/courses/1541/long_traces/sample_large2.tr
+ Simulation terminates at cycle : 118631313
--------------SHORT TRACES-------------------

 ** opening file /afs/cs.pitt.edu/courses/1541/short_traces/sample1.tr
+ Simulation terminates at cycle : 1162972

 ** opening file /afs/cs.pitt.edu/courses/1541/short_traces/sample2.tr
+ Simulation terminates at cycle : 1111579

 ** opening file /afs/cs.pitt.edu/courses/1541/short_traces/sample3.tr
+ Simulation terminates at cycle : 1297600

 ** opening file /afs/cs.pitt.edu/courses/1541/short_traces/sample4.tr
+ Simulation terminates at cycle : 3572145


Implementation notes the 5-stage pipeline simulator


	The biggest new addition to the 5-stage pipeline is the branch prediction table. To implement this, we added a struct prediction type into CPU.h which encapsulates an instruction’s prediction and the predicted branch target address. We also created a simple macro called HASH() which extracts bits 4-9 from a 32-bit address to index the branch prediction table. HASH() performs a bit shift right by 4 and then a 6-bit-mask (bitwise AND with 0x3F). We initialize the table to predict NOT TAKEN for all branches which have not been encountered. As the pipeline proceeds, we first check for a prediction from the table for all jumps and branches. If we predict either the target or the branch incorrectly, we have to squash on the next cycle. We used a second simple function to update the BTB with the new prediction and target.


Implementation notes the superscalar pipeline simulator


        To transition from the five-stage pipeline to the superscalar required first duplicating each pipeline stage and adding a PACKING buffer to hold the next super instruction to run. We then had the trace print the results from both writeback stages per cycle. Unlike the non-pipelined version, we needed more sophisticated logic to handle the fact that we might finish either 0, 1, or 2 instructions per cycle. To handle this, we kept track of how many instructions were packed each cycle in an integer counter which reset to 0 each cycle and adjusted the pacing of the pipeline accordingly.
        Next, we added logic which packed the instructions from the PREFETCH queue into the correct pipes. This was pretty tricky to get right, and we literally whiteboarded all the possible types of combinations and rubber-ducked them through the if-else conditionals which decided how to pack the instructions. It was also critical that we never ever allow a second instruction to be packed if the first one needed to stall. 
        Once we had the pipeline pulling two instructions per cycle down the correct pipes, the rest of the logic wasn’t that difficult to implement. To check for load/use hazard, we could simply reuse the function from the 5-stage pipeline and just run the check on two instructions. The only real difference is that there were really two scenarios now -- one where the first instruction was dependent and we have a double-NOOP cycle and the other where only the second instruction was dependent but we could still pack the first instruction with one NOOP. This took care of the load-use hazard.
Control hazard handling in the superscalar pipe was very simple. We pack branches and jumps which occur first lexically by themselves to avoid making mistakes, though putting a lw/sw instruction with the branch/jump is okay if the lw/sw was lexically first. Since we have no branch prediction, all we need to do is squash the whole next cycle any time a branch is taken or we execute a jump.
Lastly, we added one new function to check for data dependencies between instructions being loaded in the same cycle. This is a lot like the load/use function from before except that the first instruction didn’t necessarily need to be a load. It could potentially any instruction which writes a register that the other instruction needs to read. If such a hazard is detected, we simply pack the first instruction by itself and stall the second instruction until the next cycle.
	In addition to using the provided trace files to test the superscalar pipeline, we built a small sample trace (hazard_test_ss.tr) which checked for several data hazard scenarios which required the pipeline to stall--particularly where multiple hazards chained together to make sure that no instructions were being packed incorrectly or executed out-of-order. This was a tricky trace and revealed several bugs in the early drafts of our superscalar simulator.

Notes for both versions

	To make the pipeline calculate the correct cycle numbers, we needed to adjust the flush counter from 4 to 6 to account for the presence of the two stages prior to IF in both simulators. In the 5-stage pipe, this was PREFETCH[0] and PREFETCH[1], and in the superscalar version this was PREFETCH and PACKING. To adjust for the two shadow cycles that the pipeline executes prior to loading the first instruction into IF, we initialized cycle_counter to -2 at the beginning of the program. While probably not the most elegant solution possible, this offset corrected for the 2-cycle disparity in the end result of the simulator.
